# Generated by Grammarinator 23.7.post31+g3f15e2c.d20231108

import itertools

from math import inf
from grammarinator.runtime import *

class OberonGrammarGenerator(Generator):


    def EOF(self, parent=None):
        pass
    EOF.min_size = RuleSize(0, 0)

    def moduleDefinition(self, parent=None):
        local_ctx = dict(n=None)
        with UnparserRuleContext(self, 'moduleDefinition', parent) as current:
            self._reserve(11, self.MODULE, parent=current)
            self._reserve(10, self.Space, parent=current)
            self._reserve(9, self.ID, parent=current)
            local_ctx['n'] = current.last_child
            self._reserve(8, self.SEMI, parent=current)
            self._reserve(7, self.Newline, parent=current)
            self._reserve(6, self.Tab, parent=current)
            self._reserve(6, self.declarations, parent=current)
            self._reserve(5, self.Newline, parent=current)
            self._reserve(4, self.Tab, parent=current)
            self._reserve(1, self.block, parent=current)
            self.DOT(parent=current)
            return current
    moduleDefinition.min_size = RuleSize(2, 12)

    def declarations(self, parent=None):
        with UnparserRuleContext(self, 'declarations', parent) as current:
            with QuantifierContext(self, 0, 0, inf, RuleSize(3, 9), 0) as quant0:
                while quant0(current):
                    with AlternationContext(self, 0, (RuleSize(3, 12), RuleSize(6, 9)), 0, (1, 1)) as alt0:
                        [self.procedureDeclaration, self.localDeclaration][alt0(current)](parent=current)
            return current
    declarations.min_size = RuleSize(0, 0)

    def procedureDeclaration(self, parent=None):
        local_ctx = dict(name=None, pps=None, export=None, endname=None)
        with UnparserRuleContext(self, 'procedureDeclaration', parent) as current:
            self._reserve(11, self.PROCEDURE, parent=current)
            self._reserve(10, self.Space, parent=current)
            self._reserve(9, self.ID, parent=current)
            local_ctx['name'] = current.last_child
            with QuantifierContext(self, 0, 0, 1, RuleSize(5, 7), 9) as quant0:
                while quant0(current):
                    self.procedureParameters(parent=current)
                    local_ctx['pps'] = current.last_child
            with QuantifierContext(self, 1, 0, 1, RuleSize(1, 1), 9) as quant1:
                while quant1(current):
                    self.STAR(parent=current)
                    local_ctx['export'] = current.last_child
            self._reserve(8, self.SEMI, parent=current)
            self._reserve(7, self.Newline, parent=current)
            with QuantifierContext(self, 2, 0, inf, RuleSize(3, 10), 7) as quant2:
                while quant2(current):
                    self._reserve(9, self.Tab, parent=current)
                    with AlternationContext(self, 0, (RuleSize(3, 12), RuleSize(6, 9)), 0, (1, 1)) as alt0:
                        [self.procedureDeclaration, self.localDeclaration][alt0(current)](parent=current)
            self._reserve(6, self.Newline, parent=current)
            self._reserve(5, self.Tab, parent=current)
            self._reserve(2, self.block, parent=current)
            local_ctx['endname'] = current.last_child
            self._reserve(1, self.Newline, parent=current)
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 1) as quant3:
                while quant3(current):
                    self.Tab(parent=current)
            self.SEMI(parent=current)
            return current
    procedureDeclaration.min_size = RuleSize(2, 12)

    def procedureParameters(self, parent=None):
        local_ctx = dict(p=[])
        with UnparserRuleContext(self, 'procedureParameters', parent) as current:
            self._reserve(6, self.LPAREN, parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(4, 8), 6) as quant0:
                while quant0(current):
                    self._reserve(3, self.procedureParameter, parent=current)
                    local_ctx['p'].append(current.last_child)
                    self._reserve(2, self.Space, parent=current)
                    self._reserve(1, self.SEMI, parent=current)
                    self.Space(parent=current)
            self._reserve(1, self.procedureParameter, parent=current)
            local_ctx['p'].append(current.last_child)
            self.RPAREN(parent=current)
            return current
    procedureParameters.min_size = RuleSize(4, 7)

    def procedureParameter(self, parent=None):
        local_ctx = dict(names=[], t=None)
        with UnparserRuleContext(self, 'procedureParameter', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 2), 5) as quant0:
                while quant0(current):
                    self._reserve(1, self.VAR, parent=current)
                    self.Space(parent=current)
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 3), 5) as quant1:
                while quant1(current):
                    self._reserve(2, self.ID, parent=current)
                    local_ctx['names'].append(current.last_child)
                    self._reserve(1, self.COMMA, parent=current)
                    self.Space(parent=current)
            self._reserve(4, self.ID, parent=current)
            local_ctx['names'].append(current.last_child)
            self._reserve(3, self.Space, parent=current)
            self._reserve(2, self.COLON, parent=current)
            self._reserve(1, self.Space, parent=current)
            self.typeName(parent=current)
            local_ctx['t'] = current.last_child
            return current
    procedureParameter.min_size = RuleSize(3, 5)

    def typeName(self, parent=None):
        with UnparserRuleContext(self, 'typeName', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(4, 7), RuleSize(6, 9)), 0, (1, 1, 1)) as alt0:
                [self.typeName_simpleTypeName, self.typeName_arrayType, self.typeName_recordTypeName][alt0(current)](parent=current)
            return current
    typeName.min_size = RuleSize(2, 1)

    def recordTypeNameElements(self, parent=None):
        with UnparserRuleContext(self, 'recordTypeNameElements', parent) as current:
            self.recordElement(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(4, 7), 0) as quant0:
                while quant0(current):
                    self._reserve(6, self.SEMI, parent=current)
                    self._reserve(5, self.Newline, parent=current)
                    self.recordElement(parent=current)
            return current
    recordTypeNameElements.min_size = RuleSize(4, 5)

    def recordElement(self, parent=None):
        local_ctx = dict(ids=[], t=None)
        with UnparserRuleContext(self, 'recordElement', parent) as current:
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 3), 5) as quant0:
                while quant0(current):
                    self._reserve(2, self.ID, parent=current)
                    local_ctx['ids'].append(current.last_child)
                    self._reserve(1, self.COMMA, parent=current)
                    self.Space(parent=current)
            self._reserve(4, self.ID, parent=current)
            local_ctx['ids'].append(current.last_child)
            self._reserve(3, self.Space, parent=current)
            self._reserve(2, self.COLON, parent=current)
            self._reserve(1, self.Space, parent=current)
            self.typeName(parent=current)
            local_ctx['t'] = current.last_child
            return current
    recordElement.min_size = RuleSize(3, 5)

    def localDeclaration(self, parent=None):
        with UnparserRuleContext(self, 'localDeclaration', parent) as current:
            with AlternationContext(self, 0, (RuleSize(5, 9), RuleSize(5, 9), RuleSize(5, 9)), 0, (1, 1, 1)) as alt0:
                [self.variableDeclaration, self.constDeclaration, self.typeDeclaration][alt0(current)](parent=current)
            return current
    localDeclaration.min_size = RuleSize(5, 9)

    def typeDeclaration(self, parent=None):
        with UnparserRuleContext(self, 'typeDeclaration', parent) as current:
            self._reserve(8, self.TYPE, parent=current)
            self._reserve(7, self.Newline, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(4, 7), 0) as quant0:
                while quant0(current):
                    self.singleTypeDeclaration(parent=current)
            return current
    typeDeclaration.min_size = RuleSize(4, 9)

    def singleTypeDeclaration(self, parent=None):
        local_ctx = dict(id=None, export=None, t=None)
        with UnparserRuleContext(self, 'singleTypeDeclaration', parent) as current:
            self._reserve(6, self.ID, parent=current)
            local_ctx['id'] = current.last_child
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 6) as quant0:
                while quant0(current):
                    self.STAR(parent=current)
                    local_ctx['export'] = current.last_child
            self._reserve(5, self.Space, parent=current)
            self._reserve(4, self.EQUAL, parent=current)
            self._reserve(3, self.Space, parent=current)
            self._reserve(2, self.typeName, parent=current)
            local_ctx['t'] = current.last_child
            self._reserve(1, self.SEMI, parent=current)
            self.Newline(parent=current)
            return current
    singleTypeDeclaration.min_size = RuleSize(3, 7)

    def variableDeclaration(self, parent=None):
        with UnparserRuleContext(self, 'variableDeclaration', parent) as current:
            self._reserve(8, self.VAR, parent=current)
            self._reserve(7, self.Newline, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(4, 7), 0) as quant0:
                while quant0(current):
                    self.singleVariableDeclaration(parent=current)
            return current
    variableDeclaration.min_size = RuleSize(4, 9)

    def singleVariableDeclaration(self, parent=None):
        local_ctx = dict(v=[], t=None)
        with UnparserRuleContext(self, 'singleVariableDeclaration', parent) as current:
            with QuantifierContext(self, 0, 0, inf, RuleSize(2, 3), 7) as quant0:
                while quant0(current):
                    self._reserve(2, self.exportableID, parent=current)
                    local_ctx['v'].append(current.last_child)
                    self._reserve(1, self.COMMA, parent=current)
                    self.Space(parent=current)
            self._reserve(6, self.exportableID, parent=current)
            local_ctx['v'].append(current.last_child)
            self._reserve(5, self.Space, parent=current)
            self._reserve(4, self.COLON, parent=current)
            self._reserve(3, self.Space, parent=current)
            self._reserve(2, self.typeName, parent=current)
            local_ctx['t'] = current.last_child
            self._reserve(1, self.SEMI, parent=current)
            self.Newline(parent=current)
            return current
    singleVariableDeclaration.min_size = RuleSize(3, 7)

    def exportableID(self, parent=None):
        local_ctx = dict(export=None)
        with UnparserRuleContext(self, 'exportableID', parent) as current:
            self.ID(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.STAR(parent=current)
                    local_ctx['export'] = current.last_child
            return current
    exportableID.min_size = RuleSize(1, 1)

    def constDeclaration(self, parent=None):
        with UnparserRuleContext(self, 'constDeclaration', parent) as current:
            self._reserve(8, self.CONST, parent=current)
            self._reserve(7, self.Newline, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(4, 7), 0) as quant0:
                while quant0(current):
                    self.constDeclarationElement(parent=current)
            return current
    constDeclaration.min_size = RuleSize(4, 9)

    def constDeclarationElement(self, parent=None):
        local_ctx = dict(c=None, export=None, e=None)
        with UnparserRuleContext(self, 'constDeclarationElement', parent) as current:
            self._reserve(6, self.ID, parent=current)
            local_ctx['c'] = current.last_child
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 6) as quant0:
                while quant0(current):
                    self.STAR(parent=current)
                    local_ctx['export'] = current.last_child
            self._reserve(5, self.Space, parent=current)
            self._reserve(4, self.EQUAL, parent=current)
            self._reserve(3, self.Space, parent=current)
            self._reserve(2, self.expression, parent=current)
            local_ctx['e'] = current.last_child
            self._reserve(1, self.SEMI, parent=current)
            self.Newline(parent=current)
            return current
    constDeclarationElement.min_size = RuleSize(3, 7)

    def block(self, parent=None):
        with UnparserRuleContext(self, 'block', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 5), 3) as quant0:
                while quant0(current):
                    self._reserve(4, self.BEGIN, parent=current)
                    self._reserve(3, self.Newline, parent=current)
                    self._reserve(2, self.statements, parent=current)
                    self._reserve(1, self.Newline, parent=current)
                    self.Tab(parent=current)
            self._reserve(2, self.END, parent=current)
            self._reserve(1, self.Space, parent=current)
            self.ID(parent=current)
            return current
    block.min_size = RuleSize(1, 3)

    def statements(self, parent=None):
        with UnparserRuleContext(self, 'statements', parent) as current:
            self.Tab(parent=current)
            self.statement(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 3), 0) as quant0:
                while quant0(current):
                    self._reserve(2, self.SEMI, parent=current)
                    self._reserve(1, self.Newline, parent=current)
                    self.Tab(parent=current)
                    self.statement(parent=current)
            return current
    statements.min_size = RuleSize(1, 1)

    def statement(self, parent=None):
        with UnparserRuleContext(self, 'statement', parent) as current:
            with AlternationContext(self, 0, (RuleSize(4, 5), RuleSize(2, 1), RuleSize(4, 9), RuleSize(4, 8), RuleSize(4, 10), RuleSize(0, 0)), 0, (1, 1, 1, 1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.assign_statement(parent=current)
                elif choice0 == 1:
                    self.procCall_statement(parent=current)
                elif choice0 == 2:
                    self.while_statement(parent=current)
                elif choice0 == 3:
                    self.repeat_statement(parent=current)
                elif choice0 == 4:
                    self.if_statement(parent=current)
                elif choice0 == 5:
                    pass
            return current
    statement.min_size = RuleSize(0, 0)

    def procCall_statement(self, parent=None):
        local_ctx = dict(id=None, cp=None)
        with UnparserRuleContext(self, 'procCall_statement', parent) as current:
            self.ID(parent=current)
            local_ctx['id'] = current.last_child
            with QuantifierContext(self, 0, 0, 1, RuleSize(4, 3), 0) as quant0:
                while quant0(current):
                    self._reserve(2, self.LPAREN, parent=current)
                    self._reserve(1, self.callParameters, parent=current)
                    local_ctx['cp'] = current.last_child
                    self.RPAREN(parent=current)
            return current
    procCall_statement.min_size = RuleSize(1, 1)

    def assign_statement(self, parent=None):
        local_ctx = dict(id=None, s=None, r=None)
        with UnparserRuleContext(self, 'assign_statement', parent) as current:
            self._reserve(4, self.ID, parent=current)
            local_ctx['id'] = current.last_child
            self._reserve(4, self.selector, parent=current)
            local_ctx['s'] = current.last_child
            self._reserve(3, self.Space, parent=current)
            self._reserve(2, self.Assign, parent=current)
            self._reserve(1, self.Space, parent=current)
            self.expression(parent=current)
            local_ctx['r'] = current.last_child
            return current
    assign_statement.min_size = RuleSize(3, 5)

    def while_statement(self, parent=None):
        local_ctx = dict(r=None)
        with UnparserRuleContext(self, 'while_statement', parent) as current:
            self._reserve(8, self.WHILE, parent=current)
            self._reserve(7, self.Space, parent=current)
            self._reserve(6, self.expression, parent=current)
            local_ctx['r'] = current.last_child
            self._reserve(5, self.Space, parent=current)
            self._reserve(4, self.DO, parent=current)
            self._reserve(3, self.Newline, parent=current)
            self._reserve(2, self.statements, parent=current)
            self._reserve(1, self.Newline, parent=current)
            self.END(parent=current)
            return current
    while_statement.min_size = RuleSize(3, 9)

    def repeat_statement(self, parent=None):
        local_ctx = dict(r=None)
        with UnparserRuleContext(self, 'repeat_statement', parent) as current:
            self._reserve(7, self.REPEAT, parent=current)
            self._reserve(6, self.Newline, parent=current)
            self._reserve(5, self.statements, parent=current)
            self._reserve(4, self.Newline, parent=current)
            self._reserve(3, self.Tab, parent=current)
            self._reserve(2, self.UNTIL, parent=current)
            self._reserve(1, self.Space, parent=current)
            self.expression(parent=current)
            local_ctx['r'] = current.last_child
            return current
    repeat_statement.min_size = RuleSize(3, 8)

    def if_statement(self, parent=None):
        local_ctx = dict(c=[])
        with UnparserRuleContext(self, 'if_statement', parent) as current:
            self._reserve(9, self.IF, parent=current)
            self._reserve(8, self.Space, parent=current)
            self._reserve(7, self.expression, parent=current)
            local_ctx['c'].append(current.last_child)
            self._reserve(6, self.Space, parent=current)
            self._reserve(5, self.THEN, parent=current)
            self._reserve(4, self.Newline, parent=current)
            self._reserve(3, self.statements, parent=current)
            self._reserve(2, self.Newline, parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(3, 8), 2) as quant0:
                while quant0(current):
                    self._reserve(7, self.ELSIF, parent=current)
                    self._reserve(6, self.Space, parent=current)
                    self._reserve(5, self.expression, parent=current)
                    local_ctx['c'].append(current.last_child)
                    self._reserve(4, self.Space, parent=current)
                    self._reserve(3, self.THEN, parent=current)
                    self._reserve(2, self.Newline, parent=current)
                    self._reserve(1, self.statements, parent=current)
                    self.Newline(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 4), 2) as quant1:
                while quant1(current):
                    self._reserve(3, self.ELSE, parent=current)
                    self._reserve(2, self.Newline, parent=current)
                    self._reserve(1, self.statements, parent=current)
                    self.Newline(parent=current)
            self._reserve(1, self.Tab, parent=current)
            self.END(parent=current)
            return current
    if_statement.min_size = RuleSize(3, 10)

    def expression(self, parent=None):
        with UnparserRuleContext(self, 'expression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(4, 2), RuleSize(4, 5), RuleSize(4, 5), RuleSize(4, 5), RuleSize(2, 1), RuleSize(2, 3), RuleSize(4, 3), RuleSize(5, 4), RuleSize(2, 1)), 0, (1, 1, 1, 1, 1, 1, 1, 1, 1)) as alt0:
                [self.expression_exprNotExpression, self.expression_exprMultPrecedence, self.expression_exprFactPrecedence, self.expression_exprRelPrecedence, self.expression_exprSingleId, self.expression_exprFuncCall, self.expression_exprEmbeddedExpression, self.expression_exprConstant, self.expression_exprStringLiteral][alt0(current)](parent=current)
            return current
    expression.min_size = RuleSize(2, 1)

    def callParameters(self, parent=None):
        local_ctx = dict(p=[])
        with UnparserRuleContext(self, 'callParameters', parent) as current:
            self.expression(parent=current)
            local_ctx['p'].append(current.last_child)
            with QuantifierContext(self, 0, 0, inf, RuleSize(3, 3), 0) as quant0:
                while quant0(current):
                    self._reserve(2, self.COMMA, parent=current)
                    self._reserve(1, self.Space, parent=current)
                    self.expression(parent=current)
                    local_ctx['p'].append(current.last_child)
            return current
    callParameters.min_size = RuleSize(3, 1)

    def selector(self, parent=None):
        local_ctx = dict(i=[])
        with UnparserRuleContext(self, 'selector', parent) as current:
            with QuantifierContext(self, 0, 0, inf, RuleSize(3, 2), 0) as quant0:
                while quant0(current):
                    self.arrayOrRecordSelector(parent=current)
                    local_ctx['i'].append(current.last_child)
            return current
    selector.min_size = RuleSize(0, 0)

    def arrayOrRecordSelector(self, parent=None):
        with UnparserRuleContext(self, 'arrayOrRecordSelector', parent) as current:
            with AlternationContext(self, 0, (RuleSize(4, 3), RuleSize(2, 2)), 0, (1, 1)) as alt0:
                [self.arrayOrRecordSelector_arraySelector, self.arrayOrRecordSelector_recordSelector][alt0(current)](parent=current)
            return current
    arrayOrRecordSelector.min_size = RuleSize(2, 2)

    def STRING_LITERAL(self, parent=None):
        with UnlexerRuleContext(self, 'STRING_LITERAL', parent) as current:
            current.src += '\''
            with QuantifierContext(self, 0, 0, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                        choice0 = alt0(current)
                        if choice0 == 0:
                            current.src += '\'\''
                        elif choice0 == 1:
                            current.src += self._model.charset(current, 0, self._charsets[1])
            current.src += '\''
            return current
    STRING_LITERAL.min_size = RuleSize(0, 0)

    def Constant(self, parent=None):
        with UnlexerRuleContext(self, 'Constant', parent) as current:
            self.IntegerConstant(parent=current)
            return current
    Constant.min_size = RuleSize(3, 3)

    def IntegerConstant(self, parent=None):
        with UnlexerRuleContext(self, 'IntegerConstant', parent) as current:
            self.DigitSequence(parent=current)
            return current
    IntegerConstant.min_size = RuleSize(2, 2)

    def Sign(self, parent=None):
        with UnlexerRuleContext(self, 'Sign', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['+', '-'][alt0(current)]
            return current
    Sign.min_size = RuleSize(0, 0)

    def DigitSequence(self, parent=None):
        with UnlexerRuleContext(self, 'DigitSequence', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.Digit(parent=current)
            return current
    DigitSequence.min_size = RuleSize(1, 1)

    def Digit(self, parent=None):
        with UnlexerRuleContext(self, 'Digit', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[2])
            return current
    Digit.min_size = RuleSize(0, 0)

    def Whitespace(self, parent=None):
        with UnlexerRuleContext(self, 'Whitespace', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[3])
            return current
    Whitespace.min_size = RuleSize(0, 0)

    def Tab(self, parent=None):
        with UnlexerRuleContext(self, 'Tab', parent) as current:
            current.src += '\t'
            return current
    Tab.min_size = RuleSize(0, 0)

    def Space(self, parent=None):
        with UnlexerRuleContext(self, 'Space', parent) as current:
            current.src += ' '
            return current
    Space.min_size = RuleSize(0, 0)

    def Newline(self, parent=None):
        with UnlexerRuleContext(self, 'Newline', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    current.src += '\r'
                    with QuantifierContext(self, 0, 0, 1, RuleSize(0, 0), 0) as quant0:
                        while quant0(current):
                            current.src += '\n'
                elif choice0 == 1:
                    current.src += '\n'
            return current
    Newline.min_size = RuleSize(0, 0)

    def BlockComment(self, parent=None):
        with UnlexerRuleContext(self, 'BlockComment', parent) as current:
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.Whitespace(parent=current)
            current.src += '(*'
            with QuantifierContext(self, 1, 0, inf, RuleSize(0, 0), 0) as quant1:
                while quant1(current):
                    with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                        choice0 = alt0(current)
                        if choice0 == 0:
                            self.BlockComment(parent=current)
                        elif choice0 == 1:
                            current.src += self._model.charset(current, 0, self._charsets[0])
            current.src += '*)'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.Whitespace(parent=current)
            return current
    BlockComment.min_size = RuleSize(0, 0)

    def SEMI(self, parent=None):
        with UnlexerRuleContext(self, 'SEMI', parent) as current:
            current.src += ';'
            return current
    SEMI.min_size = RuleSize(0, 0)

    def COLON(self, parent=None):
        with UnlexerRuleContext(self, 'COLON', parent) as current:
            current.src += ':'
            return current
    COLON.min_size = RuleSize(0, 0)

    def DOT(self, parent=None):
        with UnlexerRuleContext(self, 'DOT', parent) as current:
            current.src += '.'
            return current
    DOT.min_size = RuleSize(0, 0)

    def LPAREN(self, parent=None):
        with UnlexerRuleContext(self, 'LPAREN', parent) as current:
            current.src += '('
            return current
    LPAREN.min_size = RuleSize(0, 0)

    def RPAREN(self, parent=None):
        with UnlexerRuleContext(self, 'RPAREN', parent) as current:
            current.src += ')'
            return current
    RPAREN.min_size = RuleSize(0, 0)

    def COMMA(self, parent=None):
        with UnlexerRuleContext(self, 'COMMA', parent) as current:
            current.src += ','
            return current
    COMMA.min_size = RuleSize(0, 0)

    def PLUS(self, parent=None):
        with UnlexerRuleContext(self, 'PLUS', parent) as current:
            current.src += '+'
            return current
    PLUS.min_size = RuleSize(0, 0)

    def AND(self, parent=None):
        with UnlexerRuleContext(self, 'AND', parent) as current:
            current.src += '&'
            return current
    AND.min_size = RuleSize(0, 0)

    def MINUS(self, parent=None):
        with UnlexerRuleContext(self, 'MINUS', parent) as current:
            current.src += '-'
            return current
    MINUS.min_size = RuleSize(0, 0)

    def NOTEQUAL(self, parent=None):
        with UnlexerRuleContext(self, 'NOTEQUAL', parent) as current:
            current.src += '#'
            return current
    NOTEQUAL.min_size = RuleSize(0, 0)

    def EQUAL(self, parent=None):
        with UnlexerRuleContext(self, 'EQUAL', parent) as current:
            current.src += '='
            return current
    EQUAL.min_size = RuleSize(0, 0)

    def STAR(self, parent=None):
        with UnlexerRuleContext(self, 'STAR', parent) as current:
            current.src += '*'
            return current
    STAR.min_size = RuleSize(0, 0)

    def NOT(self, parent=None):
        with UnlexerRuleContext(self, 'NOT', parent) as current:
            current.src += '~'
            return current
    NOT.min_size = RuleSize(0, 0)

    def LT(self, parent=None):
        with UnlexerRuleContext(self, 'LT', parent) as current:
            current.src += '<'
            return current
    LT.min_size = RuleSize(0, 0)

    def LE(self, parent=None):
        with UnlexerRuleContext(self, 'LE', parent) as current:
            current.src += '<='
            return current
    LE.min_size = RuleSize(0, 0)

    def GT(self, parent=None):
        with UnlexerRuleContext(self, 'GT', parent) as current:
            current.src += '>'
            return current
    GT.min_size = RuleSize(0, 0)

    def GE(self, parent=None):
        with UnlexerRuleContext(self, 'GE', parent) as current:
            current.src += '>='
            return current
    GE.min_size = RuleSize(0, 0)

    def Assign(self, parent=None):
        with UnlexerRuleContext(self, 'Assign', parent) as current:
            current.src += ':='
            return current
    Assign.min_size = RuleSize(0, 0)

    def MODULE(self, parent=None):
        with UnlexerRuleContext(self, 'MODULE', parent) as current:
            current.src += 'MODULE'
            return current
    MODULE.min_size = RuleSize(0, 0)

    def VAR(self, parent=None):
        with UnlexerRuleContext(self, 'VAR', parent) as current:
            current.src += 'VAR'
            return current
    VAR.min_size = RuleSize(0, 0)

    def BEGIN(self, parent=None):
        with UnlexerRuleContext(self, 'BEGIN', parent) as current:
            current.src += 'BEGIN'
            return current
    BEGIN.min_size = RuleSize(0, 0)

    def CONST(self, parent=None):
        with UnlexerRuleContext(self, 'CONST', parent) as current:
            current.src += 'CONST'
            return current
    CONST.min_size = RuleSize(0, 0)

    def END(self, parent=None):
        with UnlexerRuleContext(self, 'END', parent) as current:
            current.src += 'END'
            return current
    END.min_size = RuleSize(0, 0)

    def PROCEDURE(self, parent=None):
        with UnlexerRuleContext(self, 'PROCEDURE', parent) as current:
            current.src += 'PROCEDURE'
            return current
    PROCEDURE.min_size = RuleSize(0, 0)

    def TYPE(self, parent=None):
        with UnlexerRuleContext(self, 'TYPE', parent) as current:
            current.src += 'TYPE'
            return current
    TYPE.min_size = RuleSize(0, 0)

    def ARRAY(self, parent=None):
        with UnlexerRuleContext(self, 'ARRAY', parent) as current:
            current.src += 'ARRAY'
            return current
    ARRAY.min_size = RuleSize(0, 0)

    def OF(self, parent=None):
        with UnlexerRuleContext(self, 'OF', parent) as current:
            current.src += 'OF'
            return current
    OF.min_size = RuleSize(0, 0)

    def OR(self, parent=None):
        with UnlexerRuleContext(self, 'OR', parent) as current:
            current.src += 'OR'
            return current
    OR.min_size = RuleSize(0, 0)

    def RECORD(self, parent=None):
        with UnlexerRuleContext(self, 'RECORD', parent) as current:
            current.src += 'RECORD'
            return current
    RECORD.min_size = RuleSize(0, 0)

    def WHILE(self, parent=None):
        with UnlexerRuleContext(self, 'WHILE', parent) as current:
            current.src += 'WHILE'
            return current
    WHILE.min_size = RuleSize(0, 0)

    def DO(self, parent=None):
        with UnlexerRuleContext(self, 'DO', parent) as current:
            current.src += 'DO'
            return current
    DO.min_size = RuleSize(0, 0)

    def IF(self, parent=None):
        with UnlexerRuleContext(self, 'IF', parent) as current:
            current.src += 'IF'
            return current
    IF.min_size = RuleSize(0, 0)

    def THEN(self, parent=None):
        with UnlexerRuleContext(self, 'THEN', parent) as current:
            current.src += 'THEN'
            return current
    THEN.min_size = RuleSize(0, 0)

    def ELSE(self, parent=None):
        with UnlexerRuleContext(self, 'ELSE', parent) as current:
            current.src += 'ELSE'
            return current
    ELSE.min_size = RuleSize(0, 0)

    def ELSIF(self, parent=None):
        with UnlexerRuleContext(self, 'ELSIF', parent) as current:
            current.src += 'ELSIF'
            return current
    ELSIF.min_size = RuleSize(0, 0)

    def REPEAT(self, parent=None):
        with UnlexerRuleContext(self, 'REPEAT', parent) as current:
            current.src += 'REPEAT'
            return current
    REPEAT.min_size = RuleSize(0, 0)

    def UNTIL(self, parent=None):
        with UnlexerRuleContext(self, 'UNTIL', parent) as current:
            current.src += 'UNTIL'
            return current
    UNTIL.min_size = RuleSize(0, 0)

    def DIV(self, parent=None):
        with UnlexerRuleContext(self, 'DIV', parent) as current:
            current.src += ' DIV '
            return current
    DIV.min_size = RuleSize(0, 0)

    def MOD(self, parent=None):
        with UnlexerRuleContext(self, 'MOD', parent) as current:
            current.src += ' MOD '
            return current
    MOD.min_size = RuleSize(0, 0)

    def INTEGER(self, parent=None):
        with UnlexerRuleContext(self, 'INTEGER', parent) as current:
            current.src += 'INTEGER'
            return current
    INTEGER.min_size = RuleSize(0, 0)

    def BOOLEAN(self, parent=None):
        with UnlexerRuleContext(self, 'BOOLEAN', parent) as current:
            current.src += 'BOOLEAN'
            return current
    BOOLEAN.min_size = RuleSize(0, 0)

    def ID(self, parent=None):
        with UnlexerRuleContext(self, 'ID', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[4])
            with QuantifierContext(self, 0, 0, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 1, self._charsets[5])
            return current
    ID.min_size = RuleSize(0, 0)

    def ErrorChar(self, parent=None):
        with UnlexerRuleContext(self, 'ErrorChar', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[0])
            return current
    ErrorChar.min_size = RuleSize(0, 0)

    def typeName_simpleTypeName(self, parent=None):
        with UnparserRuleContext(self, 'typeName_simpleTypeName', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1, 1)) as alt0:
                [self.INTEGER, self.BOOLEAN, self.ID][alt0(current)](parent=current)
            return current
    typeName_simpleTypeName.min_size = RuleSize(1, 1)

    def typeName_arrayType(self, parent=None):
        local_ctx = dict(e=None, t=None)
        with UnparserRuleContext(self, 'typeName_arrayType', parent) as current:
            self._reserve(6, self.ARRAY, parent=current)
            self._reserve(5, self.Space, parent=current)
            self._reserve(4, self.expression, parent=current)
            local_ctx['e'] = current.last_child
            self._reserve(3, self.Space, parent=current)
            self._reserve(2, self.OF, parent=current)
            self._reserve(1, self.Space, parent=current)
            self.typeName(parent=current)
            local_ctx['t'] = current.last_child
            return current
    typeName_arrayType.min_size = RuleSize(3, 7)

    def typeName_recordTypeName(self, parent=None):
        local_ctx = dict(r=None)
        with UnparserRuleContext(self, 'typeName_recordTypeName', parent) as current:
            self._reserve(8, self.RECORD, parent=current)
            self._reserve(7, self.Space, parent=current)
            self._reserve(2, self.recordTypeNameElements, parent=current)
            local_ctx['r'] = current.last_child
            self._reserve(1, self.Space, parent=current)
            self.END(parent=current)
            return current
    typeName_recordTypeName.min_size = RuleSize(5, 9)

    def expression_exprNotExpression(self, parent=None):
        local_ctx = dict(op=None, e=None)
        with UnparserRuleContext(self, 'expression_exprNotExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 1, (1, 1)) as alt0:
                [self.NOT, self.MINUS][alt0(current)](parent=current)
            local_ctx['op'] = current.last_child
            self.expression(parent=current)
            local_ctx['e'] = current.last_child
            return current
    expression_exprNotExpression.min_size = RuleSize(3, 2)

    def expression_exprMultPrecedence(self, parent=None):
        local_ctx = dict(l=None, op=None, r=None)
        with UnparserRuleContext(self, 'expression_exprMultPrecedence', parent) as current:
            self._reserve(4, self.expression, parent=current)
            local_ctx['l'] = current.last_child
            self._reserve(3, self.Space, parent=current)
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 2, (1, 1, 1, 1)) as alt0:
                [self.STAR, self.DIV, self.MOD, self.AND][alt0(current)](parent=current)
            local_ctx['op'] = current.last_child
            self._reserve(1, self.Space, parent=current)
            self.expression(parent=current)
            local_ctx['r'] = current.last_child
            return current
    expression_exprMultPrecedence.min_size = RuleSize(3, 5)

    def expression_exprFactPrecedence(self, parent=None):
        local_ctx = dict(l=None, op=None, r=None)
        with UnparserRuleContext(self, 'expression_exprFactPrecedence', parent) as current:
            self._reserve(4, self.expression, parent=current)
            local_ctx['l'] = current.last_child
            self._reserve(3, self.Space, parent=current)
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 2, (1, 1, 1)) as alt0:
                [self.PLUS, self.MINUS, self.OR][alt0(current)](parent=current)
            local_ctx['op'] = current.last_child
            self._reserve(1, self.Space, parent=current)
            self.expression(parent=current)
            local_ctx['r'] = current.last_child
            return current
    expression_exprFactPrecedence.min_size = RuleSize(3, 5)

    def expression_exprRelPrecedence(self, parent=None):
        local_ctx = dict(l=None, op=None, r=None)
        with UnparserRuleContext(self, 'expression_exprRelPrecedence', parent) as current:
            self._reserve(4, self.expression, parent=current)
            local_ctx['l'] = current.last_child
            self._reserve(3, self.Space, parent=current)
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 2, (1, 1, 1, 1, 1, 1)) as alt0:
                [self.LT, self.LE, self.GT, self.GE, self.EQUAL, self.NOTEQUAL][alt0(current)](parent=current)
            local_ctx['op'] = current.last_child
            self._reserve(1, self.Space, parent=current)
            self.expression(parent=current)
            local_ctx['r'] = current.last_child
            return current
    expression_exprRelPrecedence.min_size = RuleSize(3, 5)

    def expression_exprSingleId(self, parent=None):
        local_ctx = dict(id=None, s=None)
        with UnparserRuleContext(self, 'expression_exprSingleId', parent) as current:
            self.ID(parent=current)
            local_ctx['id'] = current.last_child
            self.selector(parent=current)
            local_ctx['s'] = current.last_child
            return current
    expression_exprSingleId.min_size = RuleSize(1, 1)

    def expression_exprFuncCall(self, parent=None):
        local_ctx = dict(id=None, cp=None)
        with UnparserRuleContext(self, 'expression_exprFuncCall', parent) as current:
            self._reserve(2, self.ID, parent=current)
            local_ctx['id'] = current.last_child
            self._reserve(1, self.LPAREN, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(4, 1), 1) as quant0:
                while quant0(current):
                    self.callParameters(parent=current)
                    local_ctx['cp'] = current.last_child
            self.RPAREN(parent=current)
            return current
    expression_exprFuncCall.min_size = RuleSize(1, 3)

    def expression_exprEmbeddedExpression(self, parent=None):
        local_ctx = dict(e=None)
        with UnparserRuleContext(self, 'expression_exprEmbeddedExpression', parent) as current:
            self._reserve(2, self.LPAREN, parent=current)
            self._reserve(1, self.expression, parent=current)
            local_ctx['e'] = current.last_child
            self.RPAREN(parent=current)
            return current
    expression_exprEmbeddedExpression.min_size = RuleSize(3, 3)

    def expression_exprConstant(self, parent=None):
        local_ctx = dict(c=None)
        with UnparserRuleContext(self, 'expression_exprConstant', parent) as current:
            self.Constant(parent=current)
            local_ctx['c'] = current.last_child
            return current
    expression_exprConstant.min_size = RuleSize(4, 4)

    def expression_exprStringLiteral(self, parent=None):
        local_ctx = dict(s=None)
        with UnparserRuleContext(self, 'expression_exprStringLiteral', parent) as current:
            self.STRING_LITERAL(parent=current)
            local_ctx['s'] = current.last_child
            return current
    expression_exprStringLiteral.min_size = RuleSize(1, 1)

    def arrayOrRecordSelector_arraySelector(self, parent=None):
        local_ctx = dict(e=None)
        with UnparserRuleContext(self, 'arrayOrRecordSelector_arraySelector', parent) as current:
            self._reserve(2, self.T__0, parent=current)
            self._reserve(1, self.expression, parent=current)
            local_ctx['e'] = current.last_child
            self.T__1(parent=current)
            return current
    arrayOrRecordSelector_arraySelector.min_size = RuleSize(3, 3)

    def T__0(self, parent=None):
        with UnlexerRuleContext(self, 'T__0', parent) as current:
            current.src += '['
            return current
    T__0.min_size = RuleSize(0, 0)

    def T__1(self, parent=None):
        with UnlexerRuleContext(self, 'T__1', parent) as current:
            current.src += ']'
            return current
    T__1.min_size = RuleSize(0, 0)

    def arrayOrRecordSelector_recordSelector(self, parent=None):
        with UnparserRuleContext(self, 'arrayOrRecordSelector_recordSelector', parent) as current:
            self._reserve(1, self.DOT, parent=current)
            self.ID(parent=current)
            return current
    arrayOrRecordSelector_recordSelector.min_size = RuleSize(1, 2)

    _default_rule = moduleDefinition

    _charsets = {
        0: list(itertools.chain.from_iterable([range(0x20, 0x7f)])),
        1: list(itertools.chain.from_iterable([range(0x20, 0x27), range(0x28, 0x7f)])),
        2: list(itertools.chain.from_iterable([range(0x30, 0x3a)])),
        3: list(itertools.chain.from_iterable([range(0x9, 0xa), range(0x20, 0x21)])),
        4: list(itertools.chain.from_iterable([range(0x41, 0x5b), range(0x5f, 0x60), range(0x61, 0x7b)])),
        5: list(itertools.chain.from_iterable([range(0x30, 0x3a), range(0x41, 0x5b), range(0x5f, 0x60), range(0x61, 0x7b)])),
    }
